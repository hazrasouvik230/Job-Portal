import ApplicationForm from '@/ApplicationForm';
import React, { useState } from 'react'
import { useParams } from 'react-router-dom';

const JobDetails = () => {
    const specificJob = [
        {
            "_id": "68a74f9cb31b6d692607b3d0",
            "title": "MERN Developer",
            "company": "Moderator - 2's company",
            "location": "Remote",
            "jobType": "Part-Time",
            "description": "Okay, here is a professional and detailed job description for a Fresher MERN Developer, tailored to your specifications.\n\n---\n\n**Job Title:** Fresher MERN Developer\n\n**Company:** Moderator - 2's company\n\n**Location:** Remote\n\n**Job Type:** Part-Time\n\n---\n\n**About Moderator - 2's company:**\nModerator - 2's company is an innovative and growing platform dedicated to fostering safe, engaging, and collaborative online environments. We leverage cutting-edge technology to build intuitive tools and services that empower communities and individuals to connect responsibly. As we expand our reach and capabilities, we're looking for enthusiastic and talented individuals to join our technical team and help us build the next generation of our platform.\n\n**About the Role:**\nAre you a passionate and aspiring MERN Stack Developer looking to kickstart your career in a dynamic and supportive environment? Moderator - 2's company is seeking a highly motivated Fresher MERN Developer to join our remote, part-time team. This is an excellent opportunity for individuals eager to apply their foundational knowledge, learn from experienced developers, and contribute to real-world projects from the ground up. You will play a crucial role in developing and maintaining various components of our web applications, gaining hands-on experience across the entire MERN stack.\n\n**Key Responsibilities:**\n\n*   Collaborate with senior developers and the product team to understand requirements and translate them into technical solutions.\n*   Assist in the development and maintenance of scalable web applications using the MERN stack (MongoDB, Express.js, React.js, Node.js).\n*   Write clean, well-documented, and efficient code for both front-end (React.js) and back-end (Node.js/Express.js) components.\n*   Implement user interfaces and enhance user experience based on design specifications.\n*   Develop and integrate RESTful APIs for seamless communication between front-end and back-end systems.\n*   Work with MongoDB databases for data storage and retrieval, including designing schemas and querying data.\n*   Participate in code reviews, providing and receiving constructive feedback to ensure code quality and best practices.\n*   Troubleshoot, debug, and resolve issues reported by users or identified during testing.\n*   Actively learn and stay updated with the latest MERN stack technologies, tools, and industry best practices.\n*   Contribute to the continuous improvement of development processes and methodologies.\n\n**Required Skills & Qualifications:**\n\n*   **Education:** Bachelor's degree in Computer Science, Information Technology, or a related field, OR completion of a reputable coding bootcamp, OR equivalent practical experience.\n*   **JavaScript Proficiency:** Solid understanding of modern JavaScript (ES6+).\n*   **React.js:** Foundational knowledge of React.js, including components, state management, hooks, and routing.\n*   **MERN Stack Basics:**\n    *   **Node.js & Express.js:** Basic understanding of server-side development with Node.js and building APIs with Express.js.\n    *   **MongoDB:** Familiarity with NoSQL databases, specifically MongoDB, including basic CRUD operations.\n*   **Web Fundamentals:** Understanding of HTML5, CSS3, and responsive web design principles.\n*   **Version Control:** Basic familiarity with Git and GitHub for collaborative development.\n*   **Problem-Solving:** Strong analytical and problem-solving skills with an eagerness to learn and adapt.\n*   **Communication:** Excellent verbal and written communication skills, especially important for a remote team environment.\n*   **Self-Motivation:** Highly self-motivated, proactive, and capable of working independently as well as part of a team.\n*   **Eagerness to Learn:** A genuine passion for web development and a strong desire to grow your skills in the MERN stack.\n\n**Preferred (Nice-to-Have) Skills:**\n\n*   Experience with state management libraries like Redux or Context API.\n*   Familiarity with CSS frameworks (e.g., Bootstrap, Tailwind CSS, Material-UI).\n*   Basic understanding of authentication and authorization mechanisms (e.g., JWT).\n*   Knowledge of testing frameworks (e.g., Jest, React Testing Library, Mocha).\n*   A personal portfolio showcasing projects (GitHub profile, personal website, etc.) is a plus.\n\n**What We Offer:**\n\n*   **Growth Opportunity:** A unique chance to learn and grow rapidly in a real-world development environment.\n*   **Mentorship:** Direct mentorship from experienced developers eager to help you build your skills.\n*   **Flexibility:** A fully remote work environment with a flexible part-time schedule that supports work-life balance.\n*   **Impact:** The opportunity to contribute meaningfully to a growing platform and see your code in action.\n*   **Culture:** A collaborative, supportive, and inclusive team culture.\n*   **Cutting-Edge Tech:** Exposure to modern development practices and technologies.\n\n**Salary:** Negotiable, based on experience and demonstrated skills.\n\n**How to Apply:**\nInterested candidates are invited to submit their resume, a brief cover letter highlighting their interest in the MERN stack and any relevant projects or learning experiences, and a link to their GitHub profile (if available) to [Insert Application Email/Link Here]. Please use \"Fresher MERN Developer Application - [Your Name]\" as the subject line.\n\n**Moderator - 2's company is an Equal Opportunity Employer.** We celebrate diversity and are committed to creating an inclusive environment for all employees. All employment decisions are based on qualifications, merit, and business needs.\n\n---",
            "requirements": [
                "JS",
                "React",
                "MERN"
            ],
            "salary": "Negotiable",
            "experienceLevel": "Fresher",
            "postedBy": "689b7813c948a73d51fb9206",
            "deadline": "2025-08-15T00:00:00.000Z",
            "interviewQuestions": "Here are 15 best professional interview questions for a MERN Developer role, along with comprehensive answers, covering JavaScript, React, Node.js (Express), and MongoDB skills.\n\n---\n\n### **MERN Developer Interview Questions & Answers**\n\n---\n\n**Category: React.js (Frontend)**\n\n**1. Question:** Explain the concept of React Hooks. Why were they introduced, and what are their primary benefits over class components?\n**Answer:**\nReact Hooks are functions that let you \"hook into\" React state and lifecycle features from functional components. They were introduced in React 16.8 to address several pain points with class components:\n*   **Reusability of Stateful Logic:** Before Hooks, it was hard to reuse stateful logic across components without complex patterns like Higher-Order Components (HOCs) or Render Props. Hooks (e.g., custom hooks) simplify this.\n*   **Complex Class Components:** Classes can become hard to read and understand, especially with many lifecycle methods that contain unrelated logic (e.g., data fetching in `componentDidMount` and `componentDidUpdate`). `useEffect` consolidates related logic.\n*   **`this` Binding Issues:** The `this` keyword in JavaScript classes often leads to confusion and requires explicit binding. Functional components don't have `this`, eliminating this issue.\n\n**Primary Benefits:**\n*   **Simpler Code:** Less boilerplate, easier to read and write.\n*   **Improved Reusability:** Custom Hooks make it easy to extract and reuse stateful logic.\n*   **Better Organization:** `useEffect` allows you to group related logic by concern, rather than by lifecycle method.\n*   **No `this` Binding:** Eliminates a common source of bugs and confusion.\n*   **Performance:** Can potentially lead to minor performance improvements by simplifying the internal optimization mechanisms.\n\n**2. Question:** Describe the Virtual DOM and its role in React's rendering process. How does it improve performance?\n**Answer:**\nThe Virtual DOM (VDOM) is a lightweight, in-memory representation of the actual DOM. When a component's state changes in React, React first creates a new Virtual DOM tree. It then efficiently compares this new VDOM tree with the previous one (this process is called \"diffing\").\n\n**Its role and performance improvement:**\n1.  **Diffing:** React's diffing algorithm identifies the minimal set of changes required to update the real DOM.\n2.  **Batching:** Instead of updating the real DOM for every single state change, React batches multiple updates together and applies them in a single go.\n3.  **Optimized Updates:** Only the parts of the real DOM that have actually changed are updated, minimizing direct manipulation of the browser's DOM. Manipulating the real DOM is an expensive operation. By reducing these operations, React significantly improves rendering performance and provides a smoother user experience.\n\n**3. Question:** How do you manage state in a large-scale React application? When would you choose Context API over a library like Redux, or vice-versa?\n**Answer:**\nFor large-scale React applications, state management becomes crucial. Options include:\n*   **Local Component State:** `useState`, `useReducer` for state within a single component.\n*   **Lifting State Up:** Passing props down from parent to child.\n*   **React Context API:** For sharing state across a component subtree without prop drilling.\n*   **State Management Libraries:** Redux, Zustand, Recoil, MobX for global, centralized state.\n\n**Choosing between Context API and Redux:**\n*   **Context API (Built-in):**\n    *   **Pros:** Simpler setup for less complex global state, avoids prop drilling, built-in.\n    *   **Cons:** Re-renders all consumers when the context value changes (even if their props didn't), lacks developer tools for tracking state changes, not ideal for highly interconnected global state or complex async flows.\n    *   **When to choose:** For small to medium applications, theme toggling, user authentication status, or any state that doesn't change very frequently and isn't highly complex.\n\n*   **Redux (External Library):**\n    *   **Pros:** Centralized store, predictable state management (pure reducers), powerful developer tools (Redux DevTools for time-travel debugging), robust middleware for async actions (Redux-Thunk, Redux-Saga), strong community support and ecosystem.\n    *   **Cons:** More boilerplate code, steeper learning curve, can be overkill for smaller apps.\n    *   **When to choose:** For large, complex applications with highly interconnected state, frequent state updates, significant async logic, and a need for predictable state changes and robust debugging capabilities.\n\nI often start with Context API for simpler global needs and then consider Redux if complexity grows or specific Redux features become beneficial.\n\n**4. Question:** Explain the purpose of `useEffect` in React and provide an example of a common use case. What is the dependency array, and why is it important?\n**Answer:**\n`useEffect` is a React Hook that lets you perform side effects in functional components. Side effects are operations that interact with the outside world, such as data fetching, subscriptions, manual DOM manipulations, or setting up event listeners. It essentially replaces lifecycle methods like `componentDidMount`, `componentDidUpdate`, and `componentWillUnmount` for functional components.\n\n**Common Use Case Example (Data Fetching):**\n```jsx\nimport React, { useState, useEffect } from 'react';\n\nfunction UserProfile({ userId }) {\n  const [user, setUser] = useState(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n\n  useEffect(() => {\n    const fetchUser = async () => {\n      setLoading(true);\n      try {\n        const response = await fetch(`/api/users/${userId}`);\n        if (!response.ok) {\n          throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        const data = await response.json();\n        setUser(data);\n      } catch (e) {\n        setError(e);\n      } finally {\n        setLoading(false);\n      }\n    };\n\n    fetchUser();\n\n    // Cleanup function (optional, runs when component unmounts or before next effect)\n    return () => {\n      // e.g., cleanup subscriptions or timers\n    };\n  }, [userId]); // Dependency array\n\n  if (loading) return <div>Loading user...</div>;\n  if (error) return <div>Error: {error.message}</div>;\n  if (!user) return <div>No user found.</div>;\n\n  return (\n    <div>\n      <h2>{user.name}</h2>\n      <p>Email: {user.email}</p>\n    </div>\n  );\n}\n```\n\n**The Dependency Array (`[]`):**\nThe second argument to `useEffect` is an optional dependency array. It controls when the effect function re-runs:\n*   **Empty Array (`[]`):** The effect runs only once after the initial render, similar to `componentDidMount`.\n*   **No Array:** The effect runs after every render of the component, which can lead to infinite loops if not handled carefully (e.g., setting state inside the effect without a dependency array).\n*   **Array with Dependencies (`[prop1, state2]`):** The effect runs after the initial render and re-runs only if any value in the dependency array changes between renders.\n\n**Importance:** The dependency array is crucial for performance optimization and preventing infinite loops or stale closures. It tells React exactly when the effect needs to be re-synchronized with the component's state and props. Omitting dependencies when they are needed can lead to bugs where the effect uses outdated values, while including too many can lead to unnecessary re-runs.\n\n---\n\n**Category: JavaScript (Core & Asynchronous)**\n\n**5. Question:** Explain the difference between `null` and `undefined` in JavaScript. Provide scenarios where each might typically be encountered.\n**Answer:**\nBoth `null` and `undefined` represent the absence of a value, but they have distinct meanings and typical use cases:\n\n*   **`undefined`:**\n    *   Indicates that a variable has been declared but has not yet been assigned a value.\n    *   It's the default value of uninitialized variables.\n    *   It's the value returned by functions that don't explicitly return anything.\n    *   It's the value of non-existent object properties or array elements.\n    *   `typeof undefined` returns `\"undefined\"`.\n    *   *Scenarios:*\n        *   `let x; console.log(x); // undefined`\n        *   `function foo() {} console.log(foo()); // undefined`\n        *   `const obj = {}; console.log(obj.prop); // undefined`\n        *   `const arr = [1, 2]; console.log(arr[5]); // undefined`\n\n*   **`null`:**\n    *   Represents the intentional absence of any object value. It's an assignment value.\n    *   It must be explicitly assigned by a developer.\n    *   `typeof null` returns `\"object\"` (which is a historical quirk in JavaScript).\n    *   *Scenarios:*\n        *   `let user = null; // explicitly set to null, meaning no user object yet or no user logged in`\n        *   When an API returns `null` for a resource that doesn't exist (e.g., `findById(id)` might return `null` if no document matches).\n        *   Used to clear the value of a variable or property: `myElement = null;` to release a reference to a DOM element.\n\n**Key Difference:** `undefined` often implies a variable or property hasn't been *initialized* or *found*, whereas `null` implies it has been *assigned* to represent *no value*.\n\n**6. Question:** Describe the concept of the Event Loop in Node.js. How does it enable non-blocking I/O operations?\n**Answer:**\nThe Node.js Event Loop is a fundamental part of its runtime environment that enables its non-blocking, asynchronous nature. Node.js is single-threaded, meaning it executes JavaScript code sequentially. However, I/O operations (like file system access, network requests, database queries) are inherently slow. If these operations were blocking, the entire application would freeze until they completed.\n\n**How it works:**\n1.  **Call Stack:** Synchronous JavaScript code is executed here.\n2.  **Node.js APIs (or Web APIs in browsers):** When an asynchronous operation (e.g., `fs.readFile`, `http.get`, `setTimeout`) is encountered, it's offloaded to underlying C++ APIs provided by Node.js (which often use worker threads or OS-level mechanisms).\n3.  **Callback Queue (or Message Queue / Task Queue):** Once an asynchronous operation completes, its associated callback function is placed into the Callback Queue.\n4.  **Event Loop:** This is a continuous loop that constantly checks if the Call Stack is empty. If the Call Stack is empty, it picks the first callback from the Callback Queue and pushes it onto the Call Stack for execution.\n\n**Enabling Non-Blocking I/O:**\nBecause I/O operations are offloaded and their callbacks are processed later by the Event Loop *only when the main thread is idle*, the main JavaScript thread is never blocked. It can continue executing other synchronous code or processing other incoming requests while I/O operations are happening in the background. This allows Node.js to handle a large number of concurrent connections efficiently, making it well-suited for I/O-bound applications like web servers.\n\n---\n\n**Category: Node.js (Backend with Express)**\n\n**7. Question:** What is middleware in Express.js? Provide an example of how you might use a custom middleware function.\n**Answer:**\nMiddleware functions in Express.js are functions that have access to the `request` object (`req`), the `response` object (`res`), and the `next` function in the application's request-response cycle. They can execute any code, make changes to the request and response objects, end the request-response cycle, or call the next middleware function in the stack.\n\n**Common uses of middleware:**\n*   Logging requests\n*   Parsing request bodies (e.g., `body-parser` or `express.json()`)\n*   Authentication and authorization\n*   Session management\n*   Handling CORS\n*   Error handling\n\n**Example of a Custom Middleware (e.g., for logging requests):**\n\n```javascript\n// loggerMiddleware.js\nconst loggerMiddleware = (req, res, next) => {\n  const timestamp = new Date().toISOString();\n  console.log(`[${timestamp}] ${req.method} ${req.originalUrl}`);\n  // If you want to log body or query params for POST/GET:\n  // console.log('Body:', req.body);\n  // console.log('Query:', req.query);\n  next(); // Pass control to the next middleware or route handler\n};\n\nmodule.exports = loggerMiddleware;\n\n// In your main Express app file (e.g., app.js or server.js)\nconst express = require('express');\nconst app = express();\nconst loggerMiddleware = require('./loggerMiddleware');\n\n// Use the middleware globally for all routes\napp.use(loggerMiddleware);\n\n// Or use it for specific routes/groups of routes:\n// app.get('/users', loggerMiddleware, (req, res) => { ... });\n\napp.get('/', (req, res) => {\n  res.send('Hello from MERN app!');\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});\n```\nIn this example, `loggerMiddleware` intercepts every incoming request, logs its method and URL, and then calls `next()` to pass control to the subsequent route handler or middleware in the chain.\n\n**8. Question:** Explain the principles of RESTful API design. How do you apply them when building a backend with Express.js?\n**Answer:**\nREST (Representational State Transfer) is an architectural style for designing networked applications. It's not a protocol but a set of constraints that, when adhered to, lead to a scalable, stateless, and cacheable API.\n\n**Key Principles of RESTful Design:**\n1.  **Client-Server Architecture:** Separation of concerns between client and server.\n2.  **Statelessness:** Each request from client to server must contain all the information needed to understand the request. The server should not store any client context between requests.\n3.  **Cacheability:** Responses should explicitly or implicitly define themselves as cacheable or non-cacheable to prevent clients from reusing stale or inappropriate data.\n4.  **Uniform Interface:**\n    *   **Resource-Based Identification:** Resources (data entities) are identified by URIs (e.g., `/users`, `/products/123`).\n    *   **Manipulation of Resources Through Representations:** Clients interact with resources using standard HTTP methods (verbs) like GET, POST, PUT, DELETE, PATCH, which operate on representations (e.g., JSON, XML) of the resource.\n    *   **Self-descriptive Messages:** Each message includes enough information to describe how to process the message.\n    *   **Hypermedia as the Engine of Application State (HATEOAS):** Resources should contain links to related resources, guiding the client on possible actions. (Often the most challenging to fully implement.)\n5.  **Layered System:** A client cannot ordinarily tell whether it is connected directly to the end server, or to an intermediary.\n\n**Applying to Express.js:**\n*   **Routes for Resources:** Use Express routes to map HTTP methods to specific resource URLs.\n    *   `app.get('/api/users')`: Get all users (collection).\n    *   `app.post('/api/users')`: Create a new user.\n    *   `app.get('/api/users/:id')`: Get a specific user by ID.\n    *   `app.put('/api/users/:id')`: Update a specific user (full replacement).\n    *   `app.patch('/api/users/:id')`: Partially update a specific user.\n    *   `app.delete('/api/users/:id')`: Delete a specific user.\n*   **HTTP Methods:** Adhere to the standard HTTP verbs for CRUD operations.\n*   **Statelessness:** Avoid storing session data on the server; use tokens (like JWTs) for authentication where the client sends the token with each request.\n*   **JSON Representations:** Send and receive data primarily in JSON format.\n*   **Status Codes:** Use appropriate HTTP status codes (e.g., 200 OK, 201 Created, 204 No Content, 400 Bad Request, 401 Unauthorized, 404 Not Found, 500 Internal Server Error).\n*   **Error Handling:** Implement robust error handling that returns meaningful error messages and status codes to the client.\n\n**9. Question:** How do you handle authentication and authorization in a MERN stack application? What are common strategies?\n**Answer:**\nAuthentication is verifying *who* a user is, while authorization is determining *what* a user is allowed to do.\n\n**Common Strategies in MERN:**\n\n1.  **Token-Based Authentication (JWT - JSON Web Tokens):**\n    *   **Process:**\n        1.  **User Login:** Client sends credentials (username/password) to the backend.\n        2.  **Backend Verification:** Server verifies credentials (e.g., against a MongoDB user collection).\n        3.  **Token Issuance:** If valid, the server creates a JWT, signs it with a secret key, and sends it back to the client. The JWT payload typically contains user ID and roles/permissions.\n        4.  **Client Storage:** Client stores the JWT (e.g., in `localStorage`, `sessionStorage`, or an `HttpOnly` cookie).\n        5.  **Subsequent Requests:** For protected routes, the client sends the JWT in the `Authorization` header (Bearer token).\n        6.  **Backend Verification:** Server middleware intercepts requests, verifies the JWT's signature (using the secret key), and decodes the payload to get user info.\n    *   **Pros:** Stateless (server doesn't need to store sessions), scalable, works well with mobile apps.\n    *   **Cons:** JWTs cannot be invalidated once issued (until expiry), vulnerable to XSS if stored in `localStorage` (prefer `HttpOnly` cookies).\n    *   **Implementation:** `jsonwebtoken` package on Node.js.\n\n2.  **Session-Based Authentication (less common for SPAs, but possible):**\n    *   **Process:**\n        1.  **User Login:** Client sends credentials.\n        2.  **Backend Session Creation:** Server creates a session, stores session data (e.g., user ID) in memory/database (e.g., Redis, MongoDB Atlas with `connect-mongo`), and sends a session ID cookie to the client.\n        3.  **Subsequent Requests:** Client automatically sends the session ID cookie with each request.\n        4.  **Backend Verification:** Server uses the session ID to retrieve user data from the session store.\n    *   **Pros:** Simpler invalidation, generally more secure against XSS if HttpOnly cookies are used.\n    *   **Cons:** Requires server-side storage (stateful), less scalable for distributed systems.\n    *   **Implementation:** `express-session`, `passport.js` (can also be used with JWT).\n\n**Authorization (Post-Authentication):**\nOnce authenticated, authorization checks *permissions*.\n*   **Role-Based Access Control (RBAC):** Assign roles to users (e.g., 'admin', 'editor', 'viewer'). Middleware checks the user's role against the required role for a route/action.\n*   **Attribute-Based Access Control (ABAC):** More fine-grained, checks specific attributes of the user, the resource, and the environment (e.g., \"User can edit this document if they are the owner and it's not published\").\n*   **Implementation:**\n    *   Store roles/permissions in the user document in MongoDB.\n    *   Include roles/permissions in the JWT payload.\n    *   Create Express middleware that decodes the JWT (after authentication) and checks the user's roles/permissions before allowing access to a route.\n\n**Example Authorization Middleware:**\n```javascript\n// authMiddleware.js\nconst jwt = require('jsonwebtoken');\n\nconst authorize = (roles = []) => {\n  if (typeof roles === 'string') {\n    roles = [roles]; // Ensure roles is an array\n  }\n\n  return (req, res, next) => {\n    // Assume JWT is already verified and user info is attached to req.user\n    if (!req.user || !req.user.role) {\n      return res.status(401).json({ message: 'Unauthorized: No user role found' });\n    }\n\n    if (roles.length && !roles.includes(req.user.role)) {\n      // User's role is not allowed to access this route\n      return res.status(403).json({ message: 'Forbidden: You do not have the required permissions' });\n    }\n\n    next();\n  };\n};\n\nmodule.exports = authorize;\n\n// In your route:\n// const { authenticateToken } = require('./authMiddleware'); // First verify token\n// const authorize = require('./authorizeMiddleware');\n// router.get('/admin-dashboard', authenticateToken, authorize('admin'), (req, res) => { /* ... */ });\n```\n\n---\n\n**Category: MongoDB (Database)**\n\n**10. Question:** What are the key differences between SQL (Relational) and NoSQL (MongoDB) databases? When would you choose MongoDB for a project?\n**Answer:**\n**SQL (Relational Databases - e.g., PostgreSQL, MySQL):**\n*   **Schema:** Fixed, rigid schema. Data must conform to predefined tables, rows, and columns.\n*   **Data Structure:** Data is stored in tables with defined relationships (via foreign keys).\n*   **Scalability:** Primarily vertical scaling (larger server). Horizontal scaling (sharding) is complex.\n*   **ACID Properties:** Strong consistency (Atomicity, Consistency, Isolation, Durability) guarantees.\n*   **Query Language:** SQL (Structured Query Language).\n*   **Joins:** Excellent for complex joins across multiple tables.\n\n**NoSQL (MongoDB - Document Database):**\n*   **Schema:** Dynamic, flexible schema (schema-less). Documents in a collection can have different fields.\n*   **Data Structure:** Data stored in JSON-like BSON documents within collections. Supports nested documents and arrays.\n*   **Scalability:** Primarily horizontal scaling (sharding) for large data sets and high traffic.\n*   **ACID Properties:** Typically eventual consistency (sacrifices some immediate consistency for availability and partition tolerance). Transactions across multiple documents/collections are more complex or limited (though MongoDB 4.0+ introduced multi-document ACID transactions for replica sets).\n*   **Query Language:** MongoDB Query Language (MQL), which is JSON-based.\n*   **Joins:** Does not directly support traditional joins. Relationships are typically managed by embedding documents or using manual referencing and application-level joins.\n\n**When to Choose MongoDB:**\nYou would typically choose MongoDB for a project when:\n*   **Rapid Development & Iteration:** Flexible schema allows for quick changes and iterative development, ideal for agile methodologies.\n*   **Handling Unstructured/Semi-structured Data:** Perfect for data that doesn't fit neatly into rows and columns (e.g., user profiles with varying fields, IoT data, content management).\n*   **High Scalability & Big Data:** When you anticipate massive amounts of data and need to scale horizontally across many servers.\n*   **Cloud Computing & Microservices:** Its distributed nature fits well with cloud-native architectures and microservices.\n*   **Real-time Analytics & Content Delivery:** Fast read/write performance for high-throughput applications.\n*   **Hierarchical Data:** When data naturally forms a tree-like or hierarchical structure that can be easily represented as nested documents.\n*   **MERN Stack Synergy:** JSON (BSON) data structure aligns naturally with JavaScript objects in Node.js and React, simplifying data mapping and reducing impedance mismatch.\n\n**11. Question:** Explain the concept of indexing in MongoDB and why it's crucial for query performance. How do you decide which fields to index?\n**Answer:**\n**Indexing in MongoDB:**\nAn index in MongoDB is a special data structure that stores a small portion of the collection's data in an easy-to-traverse form, allowing the database to quickly locate data without scanning every document in a collection. It's similar to an index in a book; instead of reading every page to find a topic, you go to the index, find the topic, and then jump directly to the relevant page.\n\nMongoDB indexes use B-trees (balanced trees) by default.\n\n**Crucial for Query Performance because:**\n*   **Faster Lookups:** Indexes drastically reduce the number of documents MongoDB has to scan to fulfill a query. Without an index, MongoDB would perform a \"collection scan,\" checking every document.\n*   **Efficient Sorting:** Queries that involve sorting (`.sort()`) can use an index to return sorted results much faster.\n*   **Covered Queries:** In some cases, if all fields required by a query are part of an index, MongoDB can return results directly from the index without ever accessing the underlying documents, making the query extremely fast.\n*   **Enforcing Uniqueness:** Unique indexes ensure that no two documents in a collection have the same value for the indexed field(s).\n\n**Deciding Which Fields to Index:**\nDeciding on indexes involves balancing read performance gains against write performance overhead (indexes must be updated on writes/deletes/updates).\n\nKey considerations:\n1.  **Frequently Queried Fields:** Any field used in `find()`, `findOne()`, `sort()`, `aggregate()` (`$match`, `$group`), or `populate()` (in Mongoose) is a strong candidate.\n2.  **Fields in `sort()` Operations:** If you frequently sort results by a particular field, an index on that field will significantly speed up sorting.\n3.  **Fields in `$match` or `$group` Stages of Aggregation:** These stages benefit greatly from indexes.\n4.  **Unique Constraints:** Fields that must have unique values (e.g., `username`, `email`) should have a unique index.\n5.  **Compound Indexes:** For queries that frequently use multiple fields together (e.g., `db.users.find({ country: 'USA', city: 'New York' })`), a compound index `({ country: 1, city: 1 })` can be more efficient than separate single-field indexes. The order of fields in a compound index matters.\n6.  **Cardinality:** Fields with high cardinality (many unique values, e.g., `_id`, `email`) are good candidates. Fields with very low cardinality (e.g., `gender` if only male/female) might not benefit as much, as the index might not narrow down the results significantly.\n7.  **Write vs. Read Ratio:** If your application is write-heavy, adding too many indexes can degrade write performance because each index needs to be updated. Focus on indexes that yield the most significant read performance improvements.\n8.  **TTL Indexes:** For automatically expiring data (e.g., session tokens, logs), use TTL (Time-To-Live) indexes.\n\nYou should analyze your application's query patterns using MongoDB's `explain()` command to identify slow queries and optimize them with appropriate indexing.\n\n---\n\n**Category: Full Stack & Best Practices**\n\n**12. Question:** How do you handle error handling in a MERN stack application, covering both frontend and backend?\n**Answer:**\nEffective error handling is crucial for robust MERN applications.\n\n**Frontend (React):**\n*   **Asynchronous Operations (API Calls):**\n    *   Use `try...catch` blocks with `async/await` (or `.catch()` with Promises) around API calls.\n    *   Set error state variables (`setError(true)`, `setErrorMessage(error.message)`) to display user-friendly messages.\n    *   **Example:**\n        ```jsx\n        const handleSubmit = async (e) => {\n          e.preventDefault();\n          setLoading(true);\n          setError(null);\n          try {\n            const response = await fetch('/api/data', { /* ... */ });\n            if (!response.ok) {\n              const errorData = await response.json();\n              throw new Error(errorData.message || 'Something went wrong');\n            }\n            const data = await response.json();\n            // Process data\n          } catch (err) {\n            setError(err.message);\n          } finally {\n            setLoading(false);\n          }\n        };\n        ```\n*   **Component Lifecycle Errors:**\n    *   **React Error Boundaries:** These are special React components that catch JavaScript errors anywhere in their child component tree, log those errors, and display a fallback UI instead of crashing the entire application. They don't catch errors in event handlers or async code.\n    *   **Example:**\n        ```jsx\n        class ErrorBoundary extends React.Component {\n          constructor(props) {\n            super(props);\n            this.state = { hasError: false, error: null };\n          }\n          static getDerivedStateFromError(error) {\n            return { hasError: true, error: error };\n          }\n          componentDidCatch(error, errorInfo) {\n            console.error(\"ErrorBoundary caught an error:\", error, errorInfo);\n            // You can log error to an error reporting service here\n          }\n          render() {\n            if (this.state.hasError) {\n              return <h1>Something went wrong. {this.state.error && this.state.error.message}</h1>;\n            }\n            return this.props.children;\n          }\n        }\n        // Usage: <ErrorBoundary><MyProblematicComponent /></ErrorBoundary>\n        ```\n*   **User Feedback:** Display clear, concise error messages to the user (e.g., form validation errors, network issues, \"something went wrong\"). Avoid exposing raw backend error details.\n*   **Logging:** Integrate with frontend error logging services (e.g., Sentry, Bugsnag) to capture and report client-side errors for monitoring and debugging.\n\n**Backend (Node.js/Express):**\n*   **Asynchronous Operations (Database, External APIs):**\n    *   Use `try...catch` blocks within `async` route handlers or service functions.\n    *   For Promises, use `.catch()` or `await` them.\n*   **Custom Error Classes:** Define custom error classes (e.g., `AppError`, `NotFoundError`, `UnauthorizedError`) to categorize and handle specific types of errors, making the error messages and status codes more consistent.\n*   **Express Error Handling Middleware:** Express has a special error-handling middleware that takes four arguments: `(err, req, res, next)`. This middleware catches errors thrown or passed via `next(err)` from other middleware or route handlers.\n    *   **Example:**\n        ```javascript\n        // Catch-all error handler (should be the last middleware)\n        app.use((err, req, res, next) => {\n          console.error(err); // Log the error for debugging\n          // Determine status code (e.g., 500 for generic errors, 404 for not found)\n          const statusCode = err.statusCode || 500;\n          res.status(statusCode).json({\n            status: 'error',\n            message: err.message || 'Internal Server Error',\n            // In development, you might send the full stack trace:\n            // stack: process.env.NODE_ENV === 'development' ? err.stack : undefined\n          });\n        });\n\n        // Example route with error\n        app.get('/broken', (req, res, next) => {\n          try {\n            throw new Error('This is a simulated error!');\n          } catch (error) {\n            next(error); // Pass error to the error handling middleware\n          }\n        });\n\n        // For async errors without try/catch in route handlers, consider `express-async-errors` or wrap with a utility:\n        const asyncHandler = fn => (req, res, next) => {\n          Promise.resolve(fn(req, res, next)).catch(next);\n        };\n        app.get('/async-broken', asyncHandler(async (req, res, next) => {\n            const data = await SomeBrokenAsyncFunction(); // This will throw\n            res.json(data);\n        }));\n        ```\n*   **Validation Errors:** Use validation libraries (e.g., Joi, Express-Validator) to validate incoming request data and return 400 Bad Request errors with specific error messages if validation fails.\n*   **CORS Errors:** Handle Cross-Origin Resource Sharing issues correctly (e.g., using `cors` middleware).\n*   **Logging:** Use robust logging (e.g., Winston, Morgan) to log errors to files or external logging services (e.g., ELK stack, Loggly).\n*   **Process Uncaught Exceptions:** Implement `process.on('uncaughtException')` and `process.on('unhandledRejection')` to catch errors that slip past other handlers, log them, and gracefully shut down or restart the server.\n\n**Integration:**\n*   The backend should return consistent error response formats (e.g., JSON with `status`, `message`, `code` fields) and appropriate HTTP status codes.\n*   The frontend consumes these error responses and displays appropriate messages to the user.\n\n**13. Question:** What are common security vulnerabilities in MERN applications and how do you mitigate them?\n**Answer:**\nSecurity is paramount. Here are common vulnerabilities and mitigation strategies:\n\n1.  **Cross-Site Scripting (XSS):**\n    *   **Vulnerability:** Attackers inject malicious client-side scripts (e.g., JavaScript) into web pages viewed by other users. This can lead to session hijacking, data theft, etc. (e.g., via user input in comments, profiles).\n    *   **Mitigation:**\n        *   **Frontend (React):** React automatically escapes content by default when rendering JSX, preventing many XSS attacks. However, be cautious with `dangerouslySetInnerHTML`. Always sanitize user-generated content that might contain HTML before rendering it if you must use `dangerouslySetInnerHTML`.\n        *   **Backend (Node.js):** Always sanitize and escape all user input before storing it in the database and before rendering it back to the client if not handled by React's escaping. Use libraries like `DOMPurify` (frontend) or `xss` (backend).\n\n2.  **Cross-Site Request Forgery (CSRF):**\n    *   **Vulnerability:** An attacker tricks an authenticated user's browser into sending a forged request to your application (e.g., a bank transfer request), exploiting the fact that the browser automatically sends cookies (session tokens).\n    *   **Mitigation:**\n        *   **CSRF Tokens:** Implement CSRF tokens. The server generates a unique, random token for each user session and embeds it in forms or sends it as a custom HTTP header. The client sends this token with every non-GET request. The server verifies the token. Use libraries like `csurf` in Express.\n        *   **SameSite Cookies:** Set `SameSite=Lax` or `SameSite=Strict` attribute on session cookies. This prevents browsers from sending cookies with cross-site requests.\n        *   **Referer Header Check:** Verify the `Referer` header to ensure requests originate from your domain (less reliable as it can be spoofed or missing).\n\n3.  **Injection Attacks (SQL/NoSQL Injection):**\n    *   **Vulnerability:** Attackers inject malicious code into input fields, which is then executed by the database. For MongoDB, this could involve injecting query operators.\n    *   **Mitigation:**\n        *   **Parameterized Queries/ORM/ODM:** Always use a Mongoose (or Node.js native driver) methods with proper query syntax, which automatically sanitizes input. Avoid constructing queries by concatenating user input directly into strings. Mongoose typically handles this well.\n        *   **Input Validation:** Strictly validate and sanitize all user input on the server-side before processing or storing it.\n\n4.  **Broken Authentication and Session Management:**\n    *   **Vulnerability:** Weak password policies, insecure session IDs, improper token handling (e.g., JWTs not properly signed, exposed secret keys).\n    *   **Mitigation:**\n        *   **Strong Passwords & Hashing:** Store password hashes (e.g., using `bcrypt.js`) never plain text passwords. Use strong hashing algorithms with salting.\n        *   **Secure JWT Handling:**\n            *   Use strong, long, random secret keys for signing JWTs.\n            *   Set appropriate expiry times for JWTs.\n            *   Consider refreshing tokens to mitigate the risk of long-lived tokens being compromised.\n            *   Prefer `HttpOnly` cookies for storing JWTs to prevent client-side JavaScript access (XSS mitigation).\n            *   Never expose your JWT secret key.\n        *   **Rate Limiting:** Implement rate limiting on login attempts to prevent brute-force attacks (`express-rate-limit`).\n        *   **Session Expiry:** Implement proper session expiry and invalidation on logout.\n\n5.  **Sensitive Data Exposure:**\n    *   **Vulnerability:** Sensitive data (passwords, credit card numbers, PII) is not properly encrypted or protected, both in transit and at rest.\n    *   **Mitigation:**\n        *   **HTTPS/SSL/TLS:** Always use HTTPS to encrypt all communication between client and server.\n        *   **Encryption at Rest:** Encrypt sensitive data stored in the database if required by regulations (e.g., client-side encryption, or database-level encryption features).\n        *   **Environment Variables:** Store sensitive configurations (database credentials, API keys, JWT secrets) in environment variables (`.env` file using `dotenv`) and never hardcode them or commit them to version control.\n\n6.  **Missing Function Level Access Control:**\n    *   **Vulnerability:** An authenticated user can access functionality or resources they are not authorized to use (e.g., a regular user accessing admin API endpoints).\n    *   **Mitigation:**\n        *   **Server-Side Authorization:** Implement robust authorization checks on the backend for every protected route. Do not rely solely on frontend checks. Use role-based (RBAC) or attribute-based access control (ABAC) logic.\n\n**General Best Practices:**\n*   **Input Validation:** Validate all input on the server-side, even if validated on the client-side.\n*   **Least Privilege:** Give users/processes only the minimum necessary permissions.\n*   **Security Headers:** Use security-related HTTP headers (e.g., `helmet` middleware in Express for XSS protection, CSP, etc.).\n*   **Dependencies:** Regularly update Node.js modules and client-side libraries to patch known vulnerabilities. Use tools like `npm audit`.\n*   **Logging and Monitoring:** Implement comprehensive logging and monitoring to detect and respond to security incidents.\n\n**14. Question:** Describe your debugging process for a MERN application. What tools and techniques do you use?\n**Answer:**\nMy debugging process for a MERN application typically involves a systematic approach, moving from the observable symptoms to the root cause, across both frontend and backend.\n\n**General Approach:**\n1.  **Reproduce the Issue:** Understand the exact steps to reproduce the bug.\n2.  **Isolate the Problem:** Determine if it's a frontend, backend, or integration issue.\n3.  **Narrow Down:** Use tools to pinpoint the exact line of code or component.\n4.  **Fix and Verify:** Implement the fix and thoroughly test it.\n\n**Tools & Techniques:**\n\n**Frontend (React/JavaScript):**\n*   **Browser Developer Tools (Chrome DevTools, Firefox Developer Tools):**\n    *   **Console:** For `console.log()` statements (my first go-to for quick checks), error messages, and network requests.\n    *   **Elements:** Inspecting and modifying DOM, checking styles.\n    *   **Sources:** Setting breakpoints, stepping through code, inspecting variables in real-time. This is invaluable for understanding component rendering, state updates, and asynchronous flows.\n    *   **Network Tab:** Checking API request/response headers, status codes, and payloads. Crucial for verifying communication with the backend.\n    *   **Application Tab:** Inspecting `localStorage`, `sessionStorage`, cookies, and service workers.\n*   **React Developer Tools (Browser Extension):**\n    *   **Components Tab:** Inspecting component tree, current props, state, and hooks. This is incredibly powerful for understanding React's internal state.\n    *   **Profiler Tab:** Analyzing rendering performance and identifying re-renders.\n*   **Linting (ESLint):** Catches many common JavaScript errors and enforces code style, preventing bugs before they even run.\n*   **Error Boundaries:** As mentioned earlier, for gracefully handling UI errors and logging them.\n*   **Visual Studio Code Debugger:** Can attach to the browser for debugging client-side code directly in the IDE.\n\n**Backend (Node.js/Express/MongoDB):**\n*   **`console.log()`:** Still a quick and effective way to inspect variable values, execution flow, and request/response data in Express middleware or routes.\n*   **Node.js Inspector/Debugger (built-in, or via VS Code):**\n    *   Run Node.js with `node --inspect index.js`.\n    *   Open Chrome DevTools and click the green Node.js icon. This allows setting breakpoints, stepping through server-side code, inspecting variables, and evaluating expressions just like in the browser.\n    *   VS Code's built-in debugger is excellent and integrates seamlessly with `launch.json` configurations.\n*   **Postman/Insomnia/cURL:** For testing API endpoints directly, isolating backend issues from frontend integration.\n*   **MongoDB Compass/MongoDB Shell:**\n    *   **Compass:** GUI tool for browsing collections, running queries, inspecting documents, and analyzing query performance (`explain()`). Essential for debugging data issues.\n    *   **Shell (`mongosh`):** For quick command-line queries and administrative tasks.\n*   **Error Handling Middleware:** My custom error middleware on the backend logs errors to the console or a file, providing quick visibility into server-side exceptions and their stack traces.\n*   **Logging Libraries (e.g., Winston, Morgan):** For structured logging, especially in production, to track request flow, errors, and application state.\n*   **Database Debugging:**\n    *   Checking server logs (`mongod` logs).\n    *   Using Mongoose's debug mode (`mongoose.set('debug', true)`) to see the raw MongoDB queries being sent.\n\n**Integrated Debugging:**\n*   When a bug spans both frontend and backend (e.g., a data mismatch), I start by examining the network requests (browser DevTools) to see what the frontend sent and what the backend responded with.\n*   Then, I dive into the relevant layer (frontend component, backend route, database query) using breakpoints and console logs to trace the data flow and logic execution step-by-step.\n*   Checking CORS configuration is often a first step for integration issues between client and server.\n\nMy philosophy is to start with the simplest tools (console.log, network tab) to quickly narrow down the problem, then move to more powerful debuggers (VS Code debugger, React DevTools) for deeper inspection.\n\n**15. Question:** Discuss scalability considerations for a MERN application. What strategies would you employ as the application grows?\n**Answer:**\nScalability is the ability of an application to handle an increasing amount of work or users. For a MERN stack, you need to consider scaling each layer.\n\n**1. Frontend (React):**\n*   **Code Splitting/Lazy Loading:** Use `React.lazy()` and `Suspense` (or Webpack dynamic imports) to load only the necessary component code when needed, reducing initial bundle size and improving load times.\n*   **Performance Optimization:**\n    *   Memoization (`React.memo`, `useMemo`, `useCallback`) to prevent unnecessary re-renders.\n    *   Optimizing large lists (e.g., `react-window`, `react-virtualized` for virtualized scrolling).\n    *   Efficient state management.\n*   **CDN for Static Assets:** Serve static assets (JS, CSS, images) from a Content Delivery Network.\n*   **SSR/SSG (Next.js/Gatsby.js):** For highly SEO-dependent or content-heavy sites, Server-Side Rendering (SSR) or Static Site Generation (SSG) can improve initial load performance and SEO, reducing the burden on the client's browser.\n\n**2. Backend (Node.js/Express):**\n*   **Horizontal Scaling (Clustering/Load Balancing):**\n    *   **Node.js Cluster Module:** Utilize all CPU cores by running multiple Node.js processes on the same server, each handling requests.\n    *   **Process Managers (PM2):** Manage and automatically restart Node.js processes, enabling clustering and ensuring high availability.\n    *   **Load Balancers:** Distribute incoming traffic across multiple Node.js server instances (e.g., Nginx, AWS ELB, Kubernetes). This allows adding more servers as demand grows.\n*   **Statelessness:** Ensure your Express application is stateless (as discussed in REST), making it easier to scale horizontally without session synchronization issues. Use JWTs for authentication.\n*   **Asynchronous Operations & Message Queues:** Offload long-running or resource-intensive tasks (e.g., image processing, email sending, PDF generation) to background worker processes using message queues (e.g., RabbitMQ, Kafka, AWS SQS). This keeps the main Node.js event loop free to handle immediate HTTP requests.\n*   **Caching:**\n    *   **Application-level Caching:** Cache frequently accessed data in memory (e.g., using `node-cache`) or a dedicated cache store like Redis.\n    *   **HTTP Caching:** Use HTTP caching headers (Etag, Cache-Control) to leverage browser and proxy caches.\n*   **Database Connection Pooling:** Efficiently manage database connections to avoid creating a new connection for every request. Mongoose handles this automatically to some extent.\n*   **Microservices (Optional/Advanced):** For extremely large and complex applications, break down the monolithic backend into smaller, independent microservices, each handling a specific business capability. This allows independent scaling and development of services.\n\n**3. Database (MongoDB):**\n*   **Indexing:** Crucial for query performance (as discussed in Q11).\n*   **Replication (Replica Sets):**\n    *   Provides high availability and data redundancy. If the primary goes down, a secondary is elected.\n    *   Allows read scaling by directing read queries to secondary nodes (though eventual consistency must be considered).\n*   **Sharding:**\n    *   Distributes data across multiple MongoDB instances (shards).\n    *   Enables horizontal scaling for very large datasets and high write throughput by distributing data and load.\n    *   Each shard holds a subset of the data.\n*   **Proper Schema Design:**\n    *   **Embedding vs. Referencing:** Choose the right approach based on your data access patterns. Embedding often reduces the need for `$lookup` (joins) but can lead to larger documents. Referencing leads to more granular documents but requires more queries.\n    *   **Denormalization:** Judiciously denormalize data where read performance is critical, even if it means some data duplication.\n*   **Monitoring & Optimization:** Continuously monitor MongoDB performance (e.g., using MongoDB Atlas monitoring, `mongostat`, `mongotop`, `db.currentOp()`) to identify slow queries or resource bottlenecks and optimize accordingly.\n\n**Overall Strategy:**\nStart with vertical scaling for simple applications (more CPU, RAM). As demand grows, implement horizontal scaling (add more instances behind a load balancer). Adopt caching and asynchronous processing to reduce bottlenecks. For massive scale, sharding and a microservices architecture might become necessary. Always monitor performance metrics to guide your scaling decisions.",
            "applicants": [],
            "createdAt": "2025-08-21T16:55:56.527Z",
            "updatedAt": "2025-08-21T16:55:56.527Z",
            "__v": 0
        }
    ];

    const {id} = useParams();

    const date = new Date(specificJob[0].createdAt);
    const options = { month: "short", day: "2-digit", year: "numeric" };
    const formattedDate = date.toLocaleDateString("en-us", options);

    const [showApplication, setShowApplication] = useState(false);
    const handleToggleApply = () => {
        setShowApplication(!showApplication);
    }

    return (
        <div>
            <p>JobDetails: {id}</p>
            <div className='p-6 border'>
                {/* Job post header */}
                <div className='flex flex-col'>
                    <p>{specificJob[0]._id}</p>
                    <p className='text-2xl font-bold'>{specificJob[0].title}</p>
                    <p>{specificJob[0].company}</p>
                    <p>{specificJob[0].location}</p>
                    <p>Posted on: {formattedDate}</p>
                </div>

                <div>
                    <p>Details</p>                    
                    {specificJob[0].description
                        .split('\n')
                        .filter(line => line.trim() !== "")
                        .map((line, idx) => {
                            // Check for headings like "**Job Title:**"
                            const headingMatch = line.match(/^\*\*(.+?):\*\*\s*(.*)$/);
                            const bulletMatch = line.trim().startsWith("* ");

                            if (headingMatch) {
                                return (
                                    <p key={idx}>
                                        <span className="font-semibold">{headingMatch[1]}:</span> {headingMatch[2]}
                                    </p>
                                );
                            } else if (bulletMatch) {
                                return (
                                    <li key={idx} className="ml-5 list-disc">
                                        {line.replace("* ", "").trim()}
                                    </li>
                                );
                            } else if (line.startsWith("---")) {
                                return <hr key={idx} className="my-4" />;
                            } else {
                                return <p key={idx}>{line}</p>;
                            }
                        })
                    }
                </div>

                <button className='bg-cyan-500/50 px-6 py-2 rounded font-medium hover:font-bold hover:scale-110 duration-300' onClick={handleToggleApply}>{ showApplication ? "Not apply for this job" : "Apply for this job" }</button>

                {
                    showApplication && <ApplicationForm />
                }
            </div>
        </div>
    )
}

export default JobDetails;